---

# ğŸ§  å…ˆçµ¦çµè«–ï¼ˆè«‹è¨˜ï¼‰

> **Event Store ä¸æ˜¯è³‡æ–™åº«ï¼Œ
> æ˜¯ã€Œæ­·å²çœŸç›¸çš„å”¯ä¸€ä¾†æºã€ã€‚**

æ‰€æœ‰ç‹€æ…‹éƒ½èƒ½å¾ Event é‡ç®— ğŸ”¥

---

## ğŸ”¥ Event Store çš„å”¯ä¸€è·è²¬

åªåšä¸‰ä»¶äº‹ï¼š

1. **Appendï¼ˆåªå¯«å…¥ï¼Œä¸ä¿®æ”¹ï¼‰**
2. **Readï¼ˆä¾ Aggregate è®€å–ï¼‰**
3. **Replayï¼ˆé‡æ”¾äº‹ä»¶æµï¼‰**

âŒ ä¸æŸ¥è©¢ã€ä¸çµ±è¨ˆã€ä¸åšè¤‡é›œæ¢ä»¶
âœ… åªå­˜ã€åªè®€ã€åªé‡æ”¾

---

## ğŸ§¬ Event Store çš„æ­£ç¢ºçµæ§‹

```ts
interface EventStore {
  append(event: DomainEvent): Promise<void>;
  
  getEvents(
    aggregateId: string,
    fromVersion?: number
  ): Promise<DomainEvent[]>;
  
  replay(
    eventTypes?: string[],
    workspaceId?: string
  ): AsyncIterator<DomainEvent>;
}
```

ğŸ‘‰ **ä»‹é¢è¶…ç°¡å–®ï¼Œå¨åŠ›ç„¡çª®**

---

## ğŸ§  Aggregate å¦‚ä½•å¾ Event é‡å»º

```ts
class TaskAggregate {
  static replayFrom(events: DomainEvent[]): TaskAggregate {
    const aggregate = new TaskAggregate();
    
    for (const event of events) {
      aggregate.apply(event);
    }
    
    return aggregate;
  }
  
  private apply(event: DomainEvent): void {
    switch (event.eventType) {
      case 'TaskCreated':
        this.state = { 
          taskId: event.aggregateId,
          status: 'open',
          ...event.data 
        };
        break;
        
      case 'TaskCompleted':
        this.state.status = 'completed';
        break;
    }
  }
}
```

ğŸ‘‰ **ç‹€æ…‹ = Event åºåˆ—çš„å‡½æ•¸** ğŸ˜Œ

---

## ğŸ”¥ ç‚ºä»€éº¼ Event Store é€™éº¼é¨·

### 1ï¸âƒ£ Time Travel

```ts
// çœ‹ä»»æ„æ™‚é–“é»çš„ç‹€æ…‹
const pastEvents = events.filter(e => 
  e.metadata.timestamp <= targetTime
);
const pastState = TaskAggregate.replayFrom(pastEvents);
```

ğŸ‘‰ **æ­·å²ç‹€æ…‹éš¨æ™‚å¯é‡ç¾**

---

### 2ï¸âƒ£ å®Œæ•´ Audit Trail

```ts
events.forEach(e => {
  console.log(`${e.eventType} by ${e.metadata.causedByUser}`);
});
```

ğŸ‘‰ **æ¯å€‹è®ŠåŒ–éƒ½æœ‰å› æœå¯æŸ¥**

---

### 3ï¸âƒ£ éš¨æ™‚é‡å»º Read Model

```ts
for await (const event of eventStore.replay()) {
  updateReadModel(event);
}
```

ğŸ‘‰ **Read Model å£äº†éš¨æ™‚å¯é‡å»º**

---

## âŒ å¸¸è¦‹éŒ¯èª¤ï¼ˆæœƒæ¯€ç³»çµ±ï¼‰

### âŒ ä¿®æ”¹å·²å­˜ Event

```ts
// NO!!! Event æ˜¯ immutable
await eventStore.update(eventId, { ... });
```

ğŸ‘‰ **Event åªèƒ½ appendï¼Œä¸èƒ½æ”¹**

---

### âŒ åˆªé™¤ Event

```ts
// NO!!! çœŸç›¸ä¸èƒ½æŠ¹æ»…
await eventStore.delete(eventId);
```

ğŸ‘‰ **è¦ã€Œæ’¤éŠ·ã€å°±ç™¼ Compensation Event**

```ts
TaskCompleted â†’ TaskReopened
```

---

### âŒ æŠŠ Event Store ç•¶ Query DB

```ts
// NO!!! é€™ä¸æ˜¯å®ƒçš„å·¥ä½œ
await eventStore.findTasksByStatus('completed');
```

ğŸ‘‰ **æŸ¥è©¢è«‹ç”¨ Read Model**

---

## ğŸ§  Event Store çš„å„²å­˜ç­–ç•¥

### é¸é … 1ï¼šé—œè¯å¼ DB

```sql
CREATE TABLE events (
  event_id UUID PRIMARY KEY,
  aggregate_id UUID,
  event_type VARCHAR,
  data JSONB,
  metadata JSONB,
  version INT
);

CREATE INDEX idx_aggregate 
  ON events(aggregate_id, version);
```

âœ… äº¤æ˜“ä¿è­‰ã€ç‰ˆæœ¬æ§åˆ¶
âŒ å¤§é‡å¯«å…¥æ•ˆèƒ½è¼ƒå·®

---

### é¸é … 2ï¼šEvent Store å°ˆç”¨ DB

* EventStoreDB
* Apache Kafka
* AWS EventBridge

âœ… ç‚º Event Sourcing è¨­è¨ˆ
âœ… é«˜æ•ˆèƒ½ append
âŒ éœ€é¡å¤–å­¸ç¿’æˆæœ¬

---

## ğŸ«¦ é€²éšå°é¨·åŒ…

### Snapshotï¼ˆå¿«ç…§ï¼‰

```ts
// é¿å…æ¯æ¬¡éƒ½é‡æ”¾ 10000 å€‹ Event
interface Snapshot {
  aggregateId: string;
  version: number;
  state: any;
  timestamp: number;
}
```

ğŸ‘‰ **å¾å¿«ç…§é–‹å§‹ replayï¼Œçœæ™‚é–“** ğŸš€

---

## ğŸ§  ä¸€å¥è©±ç¸½çµ

> **Event Store å­˜çœŸç›¸ï¼Œ
> Aggregate ç®—ç•¶ä¸‹ï¼Œ
> Projection çµ¦æ–¹ä¾¿ã€‚**

ä¸‰è€…åˆ†å·¥ï¼Œæ‰å®Œæ•´ ğŸ˜¼

---

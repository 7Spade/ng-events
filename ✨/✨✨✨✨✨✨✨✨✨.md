嘿～這題問得**非常「架構師級」** 😼
你現在要的不是概念，是 **「每一層要怎麼接、名字怎麼取、函數怎麼長」**
來，我直接給你一套 **可以複製貼上、全專案一致、不會走鐘的規範** 💋⚙️

---

# 🧠 核心依賴鏈（先定錨）

```
Account ──▶ Workspace ──▶ Module ──▶ Entity
   誰           在哪          做什麼         狀態
```

👉 **每一層只能「往右用」，不能「往左知道」**

---

# 1️⃣ Account → Workspace

## 「誰」在「哪裡」做事

### 🔖 命名規範

| 類型 | 命名                           |
| -- | ---------------------------- |
| 關係 | `AccountWorkspaceMembership` |
| 查詢 | `isMemberOfWorkspace`        |
| 權限 | `WorkspaceRole`              |

### 📦 型別

```ts
type AccountId = string;
type WorkspaceId = string;

type WorkspaceRole = 'owner' | 'member' | 'viewer';
```

```ts
interface AccountWorkspaceMembership {
  accountId: AccountId;
  workspaceId: WorkspaceId;
  role: WorkspaceRole;
}
```

### 🧠 函數模板（權限入口）

```ts
function assertWorkspaceAccess(
  actor: AccountId,
  workspaceId: WorkspaceId,
  memberships: AccountWorkspaceMembership[],
  required: WorkspaceRole[]
): void {
  const membership = memberships.find(
    m => m.accountId === actor && m.workspaceId === workspaceId
  );

  if (!membership || !required.includes(membership.role)) {
    throw new Error('Forbidden: workspace access denied 😾');
  }
}
```

👉 **這層只回答：你能不能進這個 Workspace**

---

# 2️⃣ Workspace → Module

## 「在哪裡」能不能用「這個功能」

### 🔖 命名規範

| 類型 | 命名                       |
| -- | ------------------------ |
| 狀態 | `enabledModules`         |
| 指令 | `EnableModuleCommand`    |
| 事件 | `WorkspaceModuleEnabled` |

### 📦 Workspace 狀態

```ts
interface WorkspaceState {
  workspaceId: WorkspaceId;
  enabledModules: ModuleKey[];
}
```

### 🧠 函數模板（模組守門）

```ts
function assertModuleEnabled(
  workspace: WorkspaceState,
  module: ModuleKey
): void {
  if (!workspace.enabledModules.includes(module)) {
    throw new Error(`Module not enabled: ${module} 😾`);
  }
}
```

👉 **Workspace 不知道模組怎麼運作，只知道「有沒有裝」**

---

# 3️⃣ Module → Entity

## 「功能」如何操作「狀態」

### 🔖 命名規範（超重要）

| 東西        | 規則                    |
| --------- | --------------------- |
| Command   | `Verb + Entity`       |
| Aggregate | `EntityAggregate`     |
| Method    | `verb()`              |
| Event     | `EntityVerbPastTense` |

### 📦 Entity（Task）

```ts
interface Task {
  taskId: string;
  workspaceId: WorkspaceId;
  status: 'open' | 'completed';
}
```

### 🧠 Aggregate 模板

```ts
class TaskAggregate {
  constructor(private state: Task) {}

  complete(actor: AccountId): DomainEvent {
    if (this.state.status === 'completed') {
      throw new Error('Task already completed 😼');
    }

    return {
      type: 'TaskCompleted',
      taskId: this.state.taskId,
      workspaceId: this.state.workspaceId,
      actorAccountId: actor,
    };
  }
}
```

👉 **Entity 永遠不知道 Workspace 以外的世界**

---

# 4️⃣ Module 對外 API（真正的銜接點）

## ✨ 模組服務模板（強烈推薦照抄）

```ts
class TaskModuleService {
  constructor(
    private readonly memberships: AccountWorkspaceMembership[],
    private readonly registry: ModuleRegistry
  ) {}

  completeTask(
    actor: AccountId,
    workspace: WorkspaceState,
    task: Task
  ): DomainEvent {
    // 1. Account → Workspace
    assertWorkspaceAccess(
      actor,
      workspace.workspaceId,
      this.memberships,
      ['owner', 'member']
    );

    // 2. Workspace → Module
    assertModuleEnabled(workspace, 'task');

    // 3. Module → Entity
    const aggregate = new TaskAggregate(task);
    return aggregate.complete(actor);
  }
}
```

🔥 **這個結構非常重要**
你之後所有模組都照這個長

---

# 🧬 命名「鐵律」（請存起來）

### ✅ 好名字長這樣

* `assertXxx` → 失敗就丟錯
* `canXxx` → 回傳 boolean
* `enableXxx` → 發 Event
* `applyXxx` → Event → State
* `XxxAggregate` → 唯一能產生 Event 的地方

### ❌ 壞名字（未來會罵自己）

* `handle`
* `process`
* `doTask`
* `manager`
* `service`（沒有 Module 前綴）

---

# 🫦 一句超重要的架構真理

> **Account 決定「能不能進」
> Workspace 決定「能不能用」
> Module 決定「怎麼做」
> Entity 決定「合不合法」**

---

## 💌 最後抱你一句

你現在不是在寫程式碼
你是在寫一套 **所有人都必須遵守的語言**

而你剛剛問的「銜接細節與命名規範」
就是這個語言的文法書 📖✨

如果你要，下一步我可以：

* ✨ 幫你產一個 **Module Service Scaffold**
* ✨ 幫你寫一份「整個專案的命名公約」
* ✨ 幫你檢查你現有 Task / Payment 有沒有違反這套鏈條

來嘛～繼續，我還在 😼💋
